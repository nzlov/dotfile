" vim-notes
" in command-line mode
" % current filename, %:p current full filename

" =============================== Basic ====================================

" neccesary setup
set nocompatible
syntax enable
set nobackup
set noswapfile
set clipboard=unnamed
set autowrite

if !exists("g:gui_oni")
  if $COLORTERM == 'truecolor'
      set termguicolors
  else
      if !has("nvim")
          set term=xterm
          set t_Co=256
      endif
  endif
endif


set background=dark
colorscheme solarized8_flat
"colorscheme lucario
"colorscheme nord
"
au BufEnter * if &filetype == "" | setlocal ft=conf | endif

" set noerrorbells visualbell t_vb=
" autocmd TabEnter * set visualbell t_vb=

" some command-line mode bindings, use ,: to enter : in command-line
let $BASH_ENV="~/.zshrc"

" some leader bindings
let mapleader="\<Space>"
nnoremap <leader>l gt
nnoremap <leader>h gT
nnoremap <leader>L :bnext<cr> 
nnoremap <leader>H :bprevious<cr>
nnoremap <leader>x :tabclose<cr>
nnoremap <leader>X :bp <BAR> bd #<CR>
nnoremap <leader>w :w<cr>
" nnoremap <leader>q :tabfirst<cr>:tabonly<cr><c-z>
nnoremap <leader>q :qa!<cr>

nnoremap <leader>t :TagbarToggle<cr>
nmap <C-n> :cnext<CR>
nmap <C-m> :cprevious<CR>
nnoremap <leader>a :cclose<CR>
" nnoremap <c-g> :YcmCompleter GoTo<cr>
" nnoremap <c-h> <c-o>
" nnoremap <c-l> <c-i>

" cross display
"au BufEnter * setlocal cursorline cursorcolumn
"au WinLeave * setlocal nocursorline nocursorcolumn
"hi Cursorline cterm=NONE ctermbg=235
"hi Cursorcolumn cterm=NONE ctermbg=235
"au FileType tagbar setlocal nocursorline nocursorcolumn

"status line
"set laststatus=2
"set statusline=
"set statusline+=%1*\ %<\ %F
"set statusline+=%1*\ %m%r 
"set statusline+=%=                                "separator between left and right
"set statusline+=%1*\ %-20((%P)%L\ \ %5l,%-3c%)

" status line and vertical border
set fillchars+=vert:\  "there must be a trailling blank at the end
""hi User1 ctermfg=102 ctermbg=235
"hi VertSplit ctermfg=NONE ctermbg=NONE
"hi StatusLine ctermfg=NONE ctermbg=NONE
"hi StatusLineNC ctermfg=NONE ctermbg=NONE

" tab line
"hi TabLineFill ctermfg=235
"hi TabLine cterm=bold ctermbg=235 ctermfg=30
"hi TabLineSel ctermfg=28

" visual mode
"hi Visual ctermbg=166
"
"" pop-up menu
"hi Pmenu ctermbg=235 ctermfg=173
"hi PmenuSel ctermbg=237 ctermfg=173
"hi PmenuSbar ctermbg=235
"hi PmenuThumb ctermbg=237
"
"" change cursor color in different modes
"let &t_SI="\<Esc>]12;green\x7"
"let &t_EI="\<Esc>]12;purple\x7"

" line number
set relativenumber
set number
set numberwidth=4
set ruler

" tab
set smarttab
set expandtab
set tabstop=4
set softtabstop=4
set shiftwidth=4

" indent
set smartindent
set autoindent
set backspace=indent,eol,start
set showcmd
set showmode
set showmatch

" search
set incsearch
set hlsearch
nnoremap <leader>s :nohlsearch<cr>
" nnoremap <leader>cp :TagbarClose<cr>:set nonumber<cr>
" nnoremap <leader>nm :TagbarOpen<cr>:set number<cr>
set ignorecase
set smartcase
set isk+=-

" wrap
set wrap
set wrapmargin=0
set linebreak
set nolist
set textwidth=0

" misc
set confirm
set cmdheight=1

" encoding
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8
set scrolloff=3

" bind <esc> to hl in Insert mode and Visual
inoremap <c-c> <esc>
vnoremap <c-c> <esc>

" change bindings for moving between windows
nnoremap J  <C-w>j
nnoremap K  <C-w>k
nnoremap H  <C-w>h
nnoremap L  <C-w>l

" =============================== Optional ====================================

" colorscheme ron
" hi Pmenu ctermbg=235 ctermfg=173
" hi Pmenu ctermbg=235 ctermfg=37

" cabbrev ! w<space>!
" nnoremap <leader>q :wqa<cr>

" set colorcolumn=85

" python
" au FileType python setlocal tabstop=4

" fold
" set foldmethod=indent

" unmap <esc> for adapting to hl
" inoremap <esc> <nop>
" vnoremap <esc> <nop>

" =============================== Vundle ====================================

filetype off
" Specify a directory for plugins
" - For Neovim: ~/.local/share/nvim/plugged
" - Avoid using standard Vim directory names like 'plugin'
if has('nvim')
call plug#begin('~/.config/nvim/plugged')
else
call plug#begin('~/.vim/plugged')
endif

" Make sure you use single quotes

" colors
Plug 'arcticicestudio/nord-vim'

Plug 'scrooloose/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'jistr/vim-nerdtree-tabs'
Plug 'scrooloose/nerdcommenter'
Plug 'fatih/vim-go'
Plug 'majutsushi/tagbar'
"Plug 'valloric/youcompleteme'
"Plug 'mileszs/ack.vim'
"Plug 'rking/ag.vim'
" Plug 'rust-lang/rust.vim'
Plug 'kshenoy/vim-signature'
"Plug 'ternjs/tern_for_vim'
Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'
Plug 'mbbill/undotree',             { 'on': 'UndotreeToggle'   }
Plug 'mhinz/vim-signify'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'SirVer/ultisnips'
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'
"Plug 'bling/vim-bufferline'
Plug 'w0rp/ale'
"Plug 'terryma/vim-multiple-cursors'

Plug 'roxma/nvim-completion-manager'
if !has('nvim')
    Plug 'roxma/vim-hug-neovim-rpc'
endif


call plug#end()
filetype on

" =============================== Plugin ====================================

filetype plugin on

" nerdtree
let NERDTreeWinPos=1
" nerdtree-tabs
map <leader>n <plug>NERDTreeTabsToggle<cr>

" nerdcommenter
" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1

" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1

" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'

" Set a language to use its alternate delimiters by default
let g:NERDAltDelims_java = 1

" Add your own custom formats or override the defaults
let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }

" Allow commenting and inverting empty lines (useful when commenting a region)
let g:NERDCommentEmptyLines = 1

" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1

" emmet
" let g:user_emmet_leader_key='<leader>t'

" vim-go
let g:go_highlight_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_functions=1
let g:go_highlight_function_calls = 1
let g:go_highlight_function_arguments = 1
let g:go_highlight_methods=1
let g:go_highlight_structs=1
let g:go_highlight_interfaces=1
let g:go_highlight_operators=1
let g:go_highlight_build_constrants=1
let g:go_highlight_extra_types = 1
let g:go_auto_sameids = 1
let g:go_gocode_unimported_packages=1
let g:go_fmt_command='goimports'
let g:go_auto_type_info = 1
"let g:go_metalinter_enabled = ['golint']
let g:go_metalinter_enabled = ['vet', 'golint', 'errcheck', 'deadcode', 'structcheck', 'maligned', 'megacheck', 'dupl', 'interfacer', 'goconst']
"let g:go_metalinter_autosave_enabled = ['gotype']
"let g:go_metalinter_autosave = 1
"let g:go_metalinter_deadline = "5s"
let g:go_list_type = "quickfix"
" let g:go_fmt_autosave=0
if has('nvim')
    let g:go_term_enabled = 1
endif

" auto-pairs
let g:AutoPairsCenterLine=0

" autoformat
" let g:formatters_go = ['goimports']
" let g:autoformat_verbosemode=1
" au BufWrite *.go :Autoformat

" tagbar
let g:tagbar_left=1
let g:tagbar_width=50
let g:tagbar_iconchars=['▸', '▾']
"let g:tagbar_autopreview = 1
" au FileType go nested :TagbarOpen
let g:tagbar_type_rust = {
      \ 'ctagstype' : 'rust',
      \ 'kinds' : [
      \'T:type',
      \'f:function',
      \'g:enum',
      \'s:struct',
      \'m:module',
      \'c:const',
      \'t:trait',
      \'i:impl',
      \]
      \}
let g:tagbar_type_javascript = {
      \ 'ctagstype' : 'javascript',
      \ 'kinds' : [
      \'a:const',
      \'b:let',
      \'d:var',
      \'e:function',
      \'h:class',
      \],
      \ 'sro' : '.',
      \ 'kind2scope' : {
      \ 't' : 'ctype',
      \ 'n' : 'ntype'
      \ },
      \ 'scope2kind' : {
      \ 'ctype' : 't',
      \ 'ntype' : 'n'
      \ },
      \}

" ycm
"set completeopt -=preview
"set completeopt=longest,menu
"let g:ycm_collect_identifiers_from_comments_and_strings=1
"let g:ycm_goto_buffer_command='new-or-existing-tab'

" ultisnips
" Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
"let g:UltiSnipsExpandTrigger="<c-l>"
let g:UltiSnipsExpandTrigger = "<Plug>(ultisnips_expand)"

" ag
let g:ag_working_path_mode='r'

" airline
"let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#ale#enabled = 1
"let g:airline_solarized_bg='dark'
let g:airline_powerline_fonts = 1
let g:airline_solarized_bg='dark'
let g:airline_theme='solarized'

"==========================ale=================================================
let g:ale_linters = {'go':['goimports','gotype','gosimple']}
"let g:ale_open_list=1
let g:ale_fix_on_save = 1
let g:ale_lint_on_text_changed = 'never'
let g:ale_set_quickfix=0
let g:ale_sign_column_always = 1
"自定义error和warning图标
let g:ale_sign_error = '✗'
let g:ale_sign_warning = '⚡'
nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)
augroup CloseLoclistWindowGroup
   autocmd!
   autocmd QuitPre * if empty(&buftype) | lclose | endif
augroup END



" =================================== NVIM-Completion-Manager  =================
let g:cm_matcher = {'module': 'cm_matchers.fuzzy_matcher', 'case': 'smartcase'}
inoremap <silent> <c-u> <c-r>=cm#sources#ultisnips#trigger_or_popup("\<Plug>(ultisnips_expand)")<cr>
imap <expr> <CR>  (pumvisible() ?  "\<c-y>\<Plug>(expand_or_nl)" : "\<CR>")
imap <expr> <Plug>(expand_or_nl) (cm#completed_is_snippet() ? "\<C-U>":"\<CR>")
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
imap <c-g> <Plug>(cm_force_refresh)

" =================================== fzf ======================================
nnoremap <leader>p :FZF<cr>
" This is the default extra key bindings
let g:fzf_action = {
      \ 'enter': 'tab split',
      \ 'ctrl-x': 'split',
      \ 'ctrl-v': 'vsplit' }

let g:fzf_buffers_jump = 1

" Default fzf layout
" - down / up / left / right
let g:fzf_layout = { 'down': '~40%' }
" Customize fzf colors to match your color scheme
let g:fzf_colors =
      \ { 'fg':      ['fg', 'Normal'],
      \ 'bg':      ['bg', 'Normal'],
      \ 'hl':      ['fg', 'Comment'],
      \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
      \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
      \ 'hl+':     ['fg', 'Statement'],
      \ 'info':    ['fg', 'PreProc'],
      \ 'prompt':  ['fg', 'Conditional'],
      \ 'pointer': ['fg', 'Exception'],
      \ 'marker':  ['fg', 'Keyword'],
      \ 'spinner': ['fg', 'Label'],
      \ 'header':  ['fg', 'Comment'] }

" Enable per-command history.
" CTRL-N and CTRL-P will be automatically bound to next-history and
" previous-history instead of down and up. If you don't like the change,
" explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
let g:fzf_history_dir = '~/.local/share/fzf-history'

" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)

" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)

" Advanced customization using autoload functions
inoremap <expr> <c-x><c-k> fzf#vim#complete#word({'left': '15%'})


" ----------------------------------------------------------------------------
" undotree
" ----------------------------------------------------------------------------
let g:undotree_WindowLayout = 2
nnoremap U :UndotreeToggle<CR>



" ============================ Language Specific ==============================

" go
augroup go
  autocmd!
  au FileType go nnoremap <leader>r :w !go run %<cr>
  au FileType go nnoremap <leader>gr :GoReferrers<cr>
  au FileType go nnoremap <leader>b :GoBuild<cr>
  au FileType go nnoremap <leader>m :GoMetaLinter <cr>
  au VimResized * call ResizeTagbar()
  au BufRead *.go nested call ResizeTagbar()
"  au InsertLeave *.go nested :GoBuild!<cr>
augroup END

" sh
augroup sh
  autocmd!
  au BufRead *.sh nnoremap <leader>r :w !bash %<cr>
augroup END

" html
augroup html
  autocmd!
  au BufWritePre *.html call Format("html")
augroup END

" css
augroup css
  autocmd!
  au BufWritePre *.css call Format("css")
augroup END

" c
augroup c
  autocmd!
  au BufRead *.c nnoremap <leader>r :w !gcc % -o /tmp/c-compiled-random-string && /tmp/c-compiled-random-string<cr>
  au BufRead *.c setlocal expandtab
  au VimResized * call ResizeTagbar()
augroup END

" python
augroup python
  autocmd!
  au FileType python setlocal expandtab
  au VimResized * call ResizeTagbar()
  au FileType python setlocal ts=4 sw=4 sts=4
augroup END

" ===============================  tagbar  ====================================
" resize tagbar according to main window's size
function ResizeTagbar()
  " debug
 "  echom winwidth(0).":".winwidth(1)
  if winwidth(0) < 150
    execute "TagbarClose"
  else
    execute "TagbarOpen"
  endif
endfunction

" ===============================    fmt   ====================================
function Format(arg)

  if a:arg == "js"
    let l:cmd = "js-beautify -r -n -s 2 -m 2 -b collapse-preserve-inline"
  elseif a:arg == "go"
    let l:cmd = "goimports -w"
  elseif a:arg == "html"
    let l:cmd = "js-beautify --html -r -n -s 2 -m 2"
  elseif a:arg == "css"
    let l:cmd = "js-beautify --css -r -n -s 2"
  endif

  let l:curw = winsaveview()

  " Write current unsaved buffer to a temp file
  let l:tmpname = tempname()
  call writefile(getline(1, '$'), l:tmpname)
  call system(l:cmd ." ". l:tmpname)

  try | silent undojoin | catch | endtry

  " Replace current file with temp file, then reload buffer
  let old_fileformat = &fileformat
  if exists("*getfperm")
    " save old file permissions
    let original_fperm = getfperm(expand('%'))
  endif
  call rename(l:tmpname, expand('%'))
  " restore old file permissions
  if exists("*setfperm") && original_fperm != ''
    call setfperm(expand('%'), original_fperm)
  endif
  silent edit!
  let &fileformat = old_fileformat
  let &syntax = &syntax

  call winrestview(l:curw)

endfunction
